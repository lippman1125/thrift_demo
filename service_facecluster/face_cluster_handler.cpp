// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <gflags/gflags.h>
#include <glog/logging.h>
#include "face_cluster_handler.hpp"
#include "face_cluster/cluster.hpp"
#include "gen-cpp/face_cluster_types.h"


// Currently one sense-time algorithm instance needs about 1GB memory.
// This pool size is used to control the total memory.
DEFINE_int32(algo_instance_pool_size,
                     100,
                     "The size of motion analyse algorithm instance pool.");


using namespace std;
FaceClusterHandler::FaceClusterHandler()
{
    algo_wrapper_count_ = 0;
    algo_wrapper_pool_semaphore_.reset(new Semaphore(FLAGS_algo_instance_pool_size));
};

FaceClusterHandler::~FaceClusterHandler()
{

}

void FaceClusterHandler::Cluster(ClusterResult& _return, const ClusterInput& input)
{

    pair<unsigned long, vector<unsigned long>> cluster;
    vector<vector<float>> featurelist;

    cout << "Cluster" << std::endl;
    cout << "feature num: " << input.featurelist.size() << std::endl;
    cout << "uid: " << input.uid << std::endl;
    cout << "did: " << input.did << std::endl;

    // just convert double type to input type
    for (unsigned int i = 0; i < input.featurelist.size(); i++) {
        vector<float> feature;
        for (unsigned int j = 0; j < input.featurelist[i].size(); j++) {
            feature.push_back(input.featurelist[i][j]);
        }
        featurelist.push_back(feature);
    }

    // Gets an AlgoWrapper instance from the pool.
    bool busy = false;
    AlgoWrapper* algo_wrapper = GetAlgoWrapper(busy);
    LOG(INFO) << "algo busy: " << busy;
    if (busy) {
        _return.cluster_num = 0;
        _return.labels.clear();
        _return.busy = true;
        return;
    }
    CHECK_NOTNULL(algo_wrapper);

    cluster = algo_wrapper->AlgoImpl(featurelist);

    _return.cluster_num = cluster.first;
    for (unsigned int i = 0; i < cluster.second.size(); i++) {
        _return.labels.push_back((int)cluster.second[i]);
    }
    _return.busy = false;

    LOG(INFO) << "Successfully run face cluster algorithm. cluster num:" << cluster.first;

    // Must return the AlgoWrapper instance to the pool.
    RecycleAlgoWrapper(algo_wrapper);

}

AlgoWrapper* FaceClusterHandler::GetAlgoWrapper(bool &busy)
{
    AlgoWrapper* algo_wrapper = NULL;

    LOG(INFO) << "algo_wrapper_pool_.size():" << algo_wrapper_pool_.size();
    if (algo_wrapper_count_ == FLAGS_algo_instance_pool_size && algo_wrapper_pool_.size() <= 1) {
        busy = true;
        return NULL;
    }
    // Can't exceed the limit.
    algo_wrapper_pool_semaphore_->Wait();
    {
        // Locks the pool.
        std::lock_guard<std::mutex> lock(algo_wrapper_pool_mutex_);
        // if algo wrapper pool is not empty, get an algo wrapper
        if (!algo_wrapper_pool_.empty()) {
            algo_wrapper = algo_wrapper_pool_[algo_wrapper_pool_.size() - 1];
            algo_wrapper_pool_.pop_back();
        }
    }

    if (algo_wrapper != NULL) {
        LOG(INFO) << "Got an AlgoWrapper instance from the pool.";
        return algo_wrapper;
    } else {
        // Instantiates a new AlgoWrapper.
        algo_wrapper = new AlgoWrapper();
        {
          std::lock_guard<std::mutex> lock(algo_wrapper_pool_mutex_);
          ++algo_wrapper_count_;
          LOG(INFO) << "Successfully initialized an AlgoWrapper instance. Total count: "
                     << algo_wrapper_count_;
        }
        return algo_wrapper;
    }
}

void FaceClusterHandler::RecycleAlgoWrapper(AlgoWrapper* algo_wrapper)
{
    CHECK_NOTNULL(algo_wrapper);
    {
        std::lock_guard<std::mutex> lock(algo_wrapper_pool_mutex_);
        algo_wrapper_pool_.push_back(algo_wrapper);
    }
    algo_wrapper_pool_semaphore_->Signal();
    LOG(INFO) << "Recycled an AlgoWrapper instance.";
}

